<!DOCTYPE html>
<!-- saved from url=(0053)http://www.runoob.com/kotlin/kotlin-basic-syntax.html -->
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Kotlin 泛型</title>

	  <link rel="dns-prefetch" href="http://s.w.org/">

		<link rel="stylesheet" href="./css2/style.css" type="text/css" media="all">
		<link rel="stylesheet" href="./css2/font-awesome.min.css" media="all">
		<link rel="stylesheet" type="text/css" href="./css2/prettify.css">
	</head>
<body style="">

<!--  头部 -->

<!-- 导航栏 -->

<div class="container main">
	<!-- 中间 -->
	<div class="row">

<div class="col left-column">

	<div class="sidebar-box gallery-list">

	</div>
</div>
<div class="col middle-column">

<div class="article">

		<div class="article-body">

			<div class="article-intro" id="content">

			<h1>Kotlin 泛型</h1>
<p>泛型，即 "参数化类型"，将类型参数化，可以用在类，接口，方法上。</p>
<p>与 Java 一样，Kotlin 也提供泛型，为类型安全提供保证，消除类型强转的烦恼。</p>
<p>声明一个泛型类:</p>
<pre class="prettyprint prettyprinted" style=""><span class="kwd">class</span><span class="pln"> </span><span class="typ">Box</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;(</span><span class="pln">t</span><span class="pun">:</span><span class="pln"> T</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> value </span><span class="pun">=</span><span class="pln"> t
</span><span class="pun">}</span></pre>
<p>创建类的实例时我们需要指定类型参数:</p>
<pre class="prettyprint prettyprinted" style=""><span class="pln">val box</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Box</span><span class="pun">&lt;</span><span class="typ">Int</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Box</span><span class="pun">&lt;</span><span class="typ">Int</span><span class="pun">&gt;(</span><span class="lit">1</span><span class="pun">)</span><span class="pln">
</span><span class="com">// 或者</span><span class="pln">
val box </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Box</span><span class="pun">(</span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="com">// 编译器会进行类型推断，1 类型 Int，所以编译器知道我们说的是 Box&lt;Int&gt;。</span></pre>
<p>以下实例向泛型类 Box 传入整型数据和字符串：</p>

<pre class="prettyprint prettyprinted" style=""><span class="kwd">class</span><span class="pln"> </span><span class="typ">Box</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;(</span><span class="pln">t </span><span class="pun">:</span><span class="pln"> T</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> value </span><span class="pun">=</span><span class="pln"> t
</span><span class="pun">}</span><span class="pln">

fun main</span><span class="pun">(</span><span class="pln">args</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Array</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">&gt;)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> boxInt </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Box</span><span class="pun">&lt;</span><span class="typ">Int</span><span class="pun">&gt;(</span><span class="lit">10</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> boxString </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Box</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">&gt;(</span><span class="str">"Runoob"</span><span class="pun">)</span><span class="pln">

    println</span><span class="pun">(</span><span class="pln">boxInt</span><span class="pun">.</span><span class="pln">value</span><span class="pun">)</span><span class="pln">
    println</span><span class="pun">(</span><span class="pln">boxString</span><span class="pun">.</span><span class="pln">value</span><span class="pun">)</span><span class="pln">
</span><span class="pun">}</span></pre>
<p>输出结果为：</p>
<pre class="prettyprint prettyprinted" style=""><span class="lit">10</span><span class="pln">
</span><span class="typ">Runoob</span></pre>
<p>
定义泛型类型变量，可以完整地写明类型参数，如果编译器可以自动推定类型参数，也可以省略类型参数。
</p><p>
Kotlin 泛型函数的声明与 Java 相同，类型参数要放在函数名的前面：</p>
<pre class="prettyprint prettyprinted" style=""><span class="pln">fun </span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;</span><span class="pln"> boxIn</span><span class="pun">(</span><span class="pln">value</span><span class="pun">:</span><span class="pln"> T</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Box</span><span class="pun">(</span><span class="pln">value</span><span class="pun">)</span><span class="pln">

</span><span class="com">// 以下都是合法语句</span><span class="pln">
val box4 </span><span class="pun">=</span><span class="pln"> boxIn</span><span class="pun">&lt;</span><span class="typ">Int</span><span class="pun">&gt;(</span><span class="lit">1</span><span class="pun">)</span><span class="pln">
val box5 </span><span class="pun">=</span><span class="pln"> boxIn</span><span class="pun">(</span><span class="lit">1</span><span class="pun">)</span><span class="pln">     </span><span class="com">// 编译器会进行类型推断</span></pre>


<p>在调用泛型函数时，如果可以推断出类型参数，可以省略泛型参数。</p>
<p>以下实例创建了泛型函数 doPrintln，函数根据传入的不同类型做相应处理：</p>
<pre class="prettyprint prettyprinted" style=""><span class="pln">fun main</span><span class="pun">(</span><span class="pln">args</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Array</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">&gt;)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    val age </span><span class="pun">=</span><span class="pln"> </span><span class="lit">23</span><span class="pln">
    val name </span><span class="pun">=</span><span class="pln"> </span><span class="str">"runoob"</span><span class="pln">
    val </span><span class="kwd">bool</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pln">

    doPrintln</span><span class="pun">(</span><span class="pln">age</span><span class="pun">)</span><span class="pln">    </span><span class="com">// 整型</span><span class="pln">
    doPrintln</span><span class="pun">(</span><span class="pln">name</span><span class="pun">)</span><span class="pln">   </span><span class="com">// 字符串</span><span class="pln">
    doPrintln</span><span class="pun">(</span><span class="kwd">bool</span><span class="pun">)</span><span class="pln">   </span><span class="com">// 布尔型</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

fun </span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;</span><span class="pln"> doPrintln</span><span class="pun">(</span><span class="pln">content</span><span class="pun">:</span><span class="pln"> T</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

    </span><span class="kwd">when</span><span class="pln"> </span><span class="pun">(</span><span class="pln">content</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">is</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">-&gt;</span><span class="pln"> println</span><span class="pun">(</span><span class="str">"整型数字为 $content"</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">is</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> </span><span class="pun">-&gt;</span><span class="pln"> println</span><span class="pun">(</span><span class="str">"字符串转换为大写：${content.toUpperCase()}"</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">-&gt;</span><span class="pln"> println</span><span class="pun">(</span><span class="str">"T 不是整型，也不是字符串"</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></pre>
<p>输出结果为：</p>
<pre class="prettyprint prettyprinted" style=""><span class="pun">整型数字为</span><span class="pln"> </span><span class="lit">23</span><span class="pln">
</span><span class="pun">字符串转换为大写：</span><span class="pln">RUNOOB
T </span><span class="pun">不是整型，也不是字符串</span></pre>
<hr>
<h2>泛型约束</h2>
<p>我们可以使用泛型约束来设定一个给定参数允许使用的类型。</p>
<p>Kotlin 中使用 : 对泛型的的类型上限进行约束。</p>

<p>最常见的约束是上界(upper bound)：</p>
<pre class="prettyprint prettyprinted" style=""><span class="pln">fun </span><span class="pun">&lt;</span><span class="pln">T </span><span class="pun">:</span><span class="pln"> </span><span class="typ">Comparable</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;&gt;</span><span class="pln"> sort</span><span class="pun">(</span><span class="pln">list</span><span class="pun">:</span><span class="pln"> </span><span class="typ">List</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// ……</span><span class="pln">
</span><span class="pun">}</span></pre>
<p>Comparable<t> 的子类型可以替代 T。 例如:</t></p>
<pre class="prettyprint prettyprinted" style=""><span class="pln">sort</span><span class="pun">(</span><span class="pln">listOf</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">))</span><span class="pln"> </span><span class="com">// OK。Int 是 Comparable&lt;Int&gt; 的子类型</span><span class="pln">
sort</span><span class="pun">(</span><span class="pln">listOf</span><span class="pun">(</span><span class="typ">HashMap</span><span class="pun">&lt;</span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> </span><span class="typ">String</span><span class="pun">&gt;()))</span><span class="pln"> </span><span class="com">// 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型</span></pre>
<p>默认的上界是 Any?。</p>
<p>对于多个上界约束条件，可以用 where 子句：</p>
<pre class="prettyprint prettyprinted" style=""><span class="pln">fun </span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;</span><span class="pln"> cloneWhenGreater</span><span class="pun">(</span><span class="pln">list</span><span class="pun">:</span><span class="pln"> </span><span class="typ">List</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;,</span><span class="pln"> threshold</span><span class="pun">:</span><span class="pln"> T</span><span class="pun">):</span><span class="pln"> </span><span class="typ">List</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="kwd">where</span><span class="pln"> T </span><span class="pun">:</span><span class="pln"> </span><span class="typ">Comparable</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Cloneable</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> list</span><span class="pun">.</span><span class="pln">filter</span><span class="pun">(</span><span class="pln">it </span><span class="pun">&gt;</span><span class="pln"> threshold</span><span class="pun">).</span><span class="pln">map</span><span class="pun">(</span><span class="pln">it</span><span class="pun">.</span><span class="pln">clone</span><span class="pun">())</span><span class="pln">
    </span><span class="pun">}</span></pre>
<hr>
<h2>型变</h2>
<p>Kotlin 中没有通配符类型，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）。</p>
<h3>声明处型变</h3>
<p>声明处的类型变异使用协变注解修饰符：in、out，消费者 in, 生产者 out。</p>
<p>使用 out 使得一个类型参数协变，协变类型参数只能用作输出，可以作为返回值类型但是无法作为入参的类型：</p>
<pre class="prettyprint prettyprinted" style=""><span class="com">// 定义一个支持协变的类</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Runoob</span><span class="pun">&lt;</span><span class="kwd">out</span><span class="pln"> A</span><span class="pun">&gt;(</span><span class="pln">val a</span><span class="pun">:</span><span class="pln"> A</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    fun foo</span><span class="pun">():</span><span class="pln"> A </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> a
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

fun main</span><span class="pun">(</span><span class="pln">args</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Array</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">&gt;)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> strCo</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Runoob</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Runoob</span><span class="pun">(</span><span class="str">"a"</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> anyCo</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Runoob</span><span class="pun">&lt;</span><span class="typ">Any</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Runoob</span><span class="pun">&lt;</span><span class="typ">Any</span><span class="pun">&gt;(</span><span class="str">"b"</span><span class="pun">)</span><span class="pln">
    anyCo </span><span class="pun">=</span><span class="pln"> strCo
    println</span><span class="pun">(</span><span class="pln">anyCo</span><span class="pun">.</span><span class="pln">foo</span><span class="pun">())</span><span class="pln">   </span><span class="com">// 输出 a</span><span class="pln">
</span><span class="pun">}</span></pre><p>in 使得一个类型参数逆变，逆变类型参数只能用作输入，可以作为入参的类型但是无法作为返回值的类型：</p>
<pre class="prettyprint prettyprinted" style=""><span class="com">// 定义一个支持逆变的类</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Runoob</span><span class="pun">&lt;</span><span class="kwd">in</span><span class="pln"> A</span><span class="pun">&gt;(</span><span class="pln">a</span><span class="pun">:</span><span class="pln"> A</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    fun foo</span><span class="pun">(</span><span class="pln">a</span><span class="pun">:</span><span class="pln"> A</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

fun main</span><span class="pun">(</span><span class="pln">args</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Array</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">&gt;)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> strDCo </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Runoob</span><span class="pun">(</span><span class="str">"a"</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> anyDCo </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Runoob</span><span class="pun">&lt;</span><span class="typ">Any</span><span class="pun">&gt;(</span><span class="str">"b"</span><span class="pun">)</span><span class="pln">
    strDCo </span><span class="pun">=</span><span class="pln"> anyDCo
</span><span class="pun">}</span></pre>
<hr><h2>星号投射</h2>
<p>有些时候, 你可能想表示你并不知道类型参数的任何信息, 但是仍然希望能够安全地使用它. 这里所谓"安全地使用"是指, 对泛型类型定义一个类型投射, 要求这个泛型类型的所有的实体实例, 都是这个投射的子类型。
</p><p>
对于这个问题, Kotlin 提供了一种语法, 称为 星号投射(star-projection):</p>
<ul>
<li>假如类型定义为 Foo&lt;out T&gt; , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper ,Foo&lt;<em>&gt; 等价于 Foo&lt;out TUpper&gt; . 它表示, 当 T 未知时, 你可以安全地从 Foo&lt;</em>&gt; 中 读取TUpper 类型的值.</li>
<li>假如类型定义为 Foo&lt;in T&gt; , 其中 T 是一个反向协变的类型参数, Foo&lt;<em>&gt; 等价于 Foo&lt;inNothing&gt; . 它表示, 当 T 未知时, 你不能安全地向 Foo&lt;</em>&gt; 写入 任何东西.</li>
<li>假如类型定义为 Foo&lt;T&gt; , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper , 对于读取值的场合, Foo&lt;*&gt; 等价于 Foo&lt;out TUpper&gt; , 对于写入值的场合, 等价于 Foo&lt;in Nothing&gt; .</li>
</ul><p>如果一个泛型类型中存在多个类型参数, 那么每个类型参数都可以单独的投射. 比如, 如果类型定义为interface Function&lt;in T, out U&gt; , 那么可以出现以下几种星号投射:</p>
<ol>
<li>Function&lt;*, String&gt; , 代表 Function&lt;in Nothing, String&gt; ;</li>
<li>Function&lt;Int, *&gt; , 代表 Function&lt;Int, out Any?&gt; ;</li>
<li>Function&lt;<em>, </em>&gt; , 代表 Function&lt;in Nothing, out Any?&gt; .</li>
</ol><p>注意: 星号投射与 Java 的原生类型(raw type)非常类似, 但可以安全使用</p>


			</div>
		</div>
	</div>
</div>

<!-- 右边栏 -->
<div class="fivecol last right-column">

<style>
.sidebar-tree .double-li {
	width:300px;
}
.sidebar-tree .double-li li {
    width: 44%;
    line-height: 1.5em;
    border-bottom: 1px solid #ccc;
    float: left;
    display: inline;
}
</style>

<style>
ol,ul{list-style:none}.cd-switcher a{text-decoration:none;outline:0}.cd-switcher a:hover{text-decoration:underline}a:focus{outline:0;-moz-outline:0}.main_nav{width:300px;height:60px;margin:60px auto 10px auto}.main_nav li{float:left;width:60px;margin-right:10px;font-size:16px;padding:.6em 1em;border-radius:3em;background:#2f889a;text-align:center}.main_nav li a{color:#fff}.errtip{background-color:#fceaea;color:#db5353;padding:8px 15px;font-size:14px;border:1px solid #fc9797;border-radius:5px}.cd-user-modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(52,54,66,0.9);z-index:3;overflow-y:auto;cursor:pointer;visibility:hidden;opacity:0;-webkit-transition:opacity .3s 0,visibility 0 .3s;-moz-transition:opacity .3s 0,visibility 0 .3s;transition:opacity .3s 0,visibility 0 .3s}.cd-user-modal.is-visible{visibility:visible;opacity:1;-webkit-transition:opacity .3s 0,visibility 0 0;-moz-transition:opacity .3s 0,visibility 0 0;transition:opacity .3s 0,visibility 0 0}.cd-user-modal.is-visible .cd-user-modal-container{-webkit-transform:translateY(0);-moz-transform:translateY(0);-ms-transform:translateY(0);-o-transform:translateY(0);transform:translateY(0)}.cd-user-modal-container{position:relative;width:90%;max-width:500px;background:#FFF;margin:3em auto 4em;cursor:auto;border-radius:.25em;-webkit-transform:translateY(-30px);-moz-transform:translateY(-30px);-ms-transform:translateY(-30px);-o-transform:translateY(-30px);transform:translateY(-30px);-webkit-transition-property:-webkit-transform;-moz-transition-property:-moz-transform;transition-property:transform;-webkit-transition-duration:.3s;-moz-transition-duration:.3s;transition-duration:.3s}.cd-user-modal-container .cd-switcher:after{content:"";display:table;clear:both}.cd-user-modal-container .cd-switcher li{width:50%;float:left;text-align:center}.cd-user-modal-container .cd-switcher li:first-child a{border-radius:.25em 0 0 0}.cd-user-modal-container .cd-switcher li:last-child a{border-radius:0 .25em 0 0}.cd-user-modal-container .cd-switcher a{font-size:1.2em;font-weight:bold;display:block;width:100%;height:50px;line-height:50px;background:#e8f1e2;color:#96b880}.cd-user-modal-container .cd-switcher a.selected{background:#FFF;color:#505260}@media only screen and (min-width:600px){.cd-user-modal-container{margin:4em auto}.cd-user-modal-container .cd-switcher a{height:70px;line-height:70px}}.cd-form{padding:1.4em}.cd-form .fieldset{position:relative;margin:1.4em 0}.cd-form .fieldset:first-child{margin-top:0}.cd-form .fieldset:last-child{margin-bottom:0}.cd-form label{font-size:16px;font-size:.875rem}.cd-form label.image-replace{display:inline-block;position:absolute;left:15px;top:50%;bottom:auto;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);-o-transform:translateY(-50%);transform:translateY(-50%);height:20px;width:20px;overflow:hidden;text-indent:100%;white-space:nowrap;color:transparent;text-shadow:none;background-repeat:no-repeat;background-position:50% 0}.cd-form label.cd-username{background-image:url("/wp-content/themes/runoob/assets/img/cd-icon-username.svg")}.cd-form label.cd-email{background-image:url("/wp-content/themes/runoob/assets/img/cd-icon-email.svg")}.cd-form label.cd-password{background-image:url("/wp-content/themes/runoob/assets/img/cd-icon-password.svg")}.cd-form input{margin:0;padding:0;border-radius:.25em}.cd-form input.full-width{width:80%}.cd-form input.full-width2{width:94%}.cd-form input.has-padding{padding:12px 20px 12px 50px}.cd-form input.has-border{border:1px solid #d2d8d8;-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none;-o-appearance:none;appearance:none}.cd-form input.has-border:focus{border-color:#98b880;box-shadow:0 0 5px rgba(52,54,66,0.1);outline:0}.cd-form input.has-error{border:1px solid #d76666}.cd-form input[type=password]{padding-right:65px}.cd-form input[type=submit]{padding:16px 0;cursor:pointer;background:#96b97d;color:#FFF;font-weight:bold;border:0;-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none;-o-appearance:none;appearance:none;font-size:1.2em;font-weight:bold}.no-touch .cd-form input[type=submit]:hover,.no-touch .cd-form input[type=submit]:focus{background:#3599ae;outline:0}@media only screen and (min-width:600px){.cd-form{padding:2em}.cd-form .fieldset{margin:2em 0}.cd-form .fieldset:first-child{margin-top:0}.cd-form .fieldset:last-child{margin-bottom:0}.cd-form input.has-padding{padding:16px 20px 16px 50px}.cd-form input[type=submit]{padding:16px 0}}.cd-close-form{display:block;position:absolute;width:40px;height:40px;right:0;top:-40px;background:url("/wp-content/themes/runoob/assets/img/cd-icon-close.svg") no-repeat center center;text-indent:100%;white-space:nowrap;overflow:hidden}@media only screen and (min-width:1170px){}#cd-login,#cd-signup,#cd-reset-password{display:none}#cd-login.is-selected,#cd-signup.is-selected,#cd-reset-password.is-selected{display:block}
</style>


</body></html>
